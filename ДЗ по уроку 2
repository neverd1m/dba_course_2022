
    1. Создать новый проект в Google Cloud Platform, например postgres2022-, где yyyymmdd год, месяц и день вашего рождения (имя проекта должно быть уникально на уровне GCP)
    дать возможность доступа к этому проекту пользователю ifti@yandex.ru с ролью Project Editor
    
    
    2. зайти удаленным ssh (первая сессия), не забывайте про ssh-add. Поставить PostgreSQ. Зайти вторым ssh (вторая сессия).
    Запустить везде psql из под пользователя postgres.
    выключить auto commit    
    сделать в первой сессии новую таблицу и наполнить ее данными create table persons(id serial, first_name text, second_name text); insert into persons(first_name, second_name) values('ivan', 'ivanov'); insert into persons(first_name, second_name) values('petr', 'petrov'); commit;
    посмотреть текущий уровень изоляции: show transaction isolation level
    
    начать новую транзакцию в обоих сессиях с дефолтным (не меняя) уровнем изоляции
    в первой сессии добавить новую запись insert into persons(first_name, second_name) values('sergey', 'sergeev');
    сделать select * from persons во второй сессии
    видите ли вы новую запись и если да то почему?
    Предварительно мы выключили опцию автокоммита, а значит транзакция еще не применилась. Т.е. мы избегаем грязного чтения, т.к. транзакция потенциально еще может быть отменена.
    
    завершить первую транзакцию - commit;
    сделать select * from persons во второй сессии
    видите ли вы новую запись и если да то почему?
    Запись теперь видна, потому что дефолтный уровень изоляции (read commited) позволяет аномалию, при которой повторное выполнение команды select во второй сесии увидит изменения.
    
    завершите транзакцию во второй сессии
    начать новые но уже repeatable read транзации - set transaction isolation level repeatable read;
    в первой сессии добавить новую запись insert into persons(first_name, second_name) values('sveta', 'svetova');
    сделать select * from persons во второй сессии
    видите ли вы новую запись и если да то почему?
    Как и прежде, пока мы не применили коммит транзакции, мы не позволяем читать изменения, которые могут быть не применены.
    
    завершить первую транзакцию - commit;
    сделать select * from persons во второй сессии
    видите ли вы новую запись и если да то почему?
    При повторном выполнении команды во второй сессии, мы все еще находимся в той же транзакции что и первом выполении select, а значит состояние таблицы применяется таким, каким было в начале транзакции. Таким образом мы избегаем фантомного чтения данных в рамках одной транзакции.
    
    завершить вторую транзакцию
    сделать select * from persons во второй сессии
    видите ли вы новую запись и если да то почему?
    Теперь запрос выполняется в рамках новой транзакции, и на момент ее выполнения данные из первой сессии доступны для чтения.
    
    

